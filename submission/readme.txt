With the last installment of what I am going to retroactively name the twilight saga, I am going to break with literary tradition and use this write up as a short love story between the Monad, the Glasgow Haskell Compiler and myself. It is a very short story that ends with no single bond stronger than the bond I formed with the delete button. And while the typical department store romance novels have a plot ark this one unfortunately does not.
- - - - - - - - - - - - - - - - - - - - - -

    A learned Interpreter for the Renaissance Man

Our interpreter began its life with a whimper. Haskell being the only real language left to choose had left a bad taste in our mouths after pa1. This taste would slowly go away as we gradually drank more and more of that special kind of Kool-Aid. But at the beginning, all we had was the opposite of boundless excitement and the GHCi.

This was the mindset upon which we started our final and ultimate quest and it worked out pretty well. Our first serious pass at the interpreter involved abusing the tree parsing code we had written for PA4. Haskell like Ocaml let us easily parse the important bits of any cl-type file with relative ease and hundreds of lines of code.

With the implementation map and class map loaded up as trees of disjoint union types in Haskell's memory we were ready to call (new Main).main() and have it print “hello world” for the entire grading server to see. But before we could do that, we had to realize that (new Main) was actually a rather large and complicated beast. Missed deadlines and error throwing code that happened to print “hello world” aside we bested this foe.

With the checkpoint slain, (new Main) and copy worked exactly the way we wanted them to work. And yet it was not exactly how they were supposed to work. You see, ever since the beginning of the course the bold and dashing members of our team had been confused by how cool actually initialized and copied values. Was it pass by reference or pass by value? What really constitutes a Cool Value? What did the reference interpreter actually do? We could seemingly construct examples and counter examples at will proving the other wrong at every step.

The only thing that had the insight to untangle this Gordian knot were the denizens piazza. Using all that we had we were finally convinced that the answer lay in the cryptic words of 'the instructor.' After hearing these wise words we became enlightened. Cool copies objects by reference and primitives by value and so in our implementation we copy everything and it works flawlessly.

And again much later, after many years of struggle, the troll like hobgoblins of that internet cave came to our aid and saved us from a pit of doom and despair known as the Monad. Much like the Sarlacc pit in the final Stars Wars (episode 6), the Monad consumes all who try to delve into it. However, after being handed proper spelunking gear and a worked example by the mysterious and helpful 'rolph' we descended into the Monad itself. After some time among the Monoids, it was not the IO Monad alone that we ended up constructing, but a state transformer that handled both our store and the intractable Haskell IO simultaneously. And so we formed a platonic love for this inexplicable monster.

Thanks to these total strangers our interpreter could now recursively execute arbitrary cool programs and update all of its state by simply returning. It understood enough logic to simulate any other simulator and it was far more importantly printing “Hello world.” Few things could have prepared us for what followed next. Implementing just the core functionality of cool gets you past most of the prompts the ancient centos box uses to judge students understanding. So after submitting to the wise and cruel centos, it told us that we were all but done. In short, the grading server was not nice to us!

The rule with which we had the most difficulty was that of new. We needed a way to update the state of the store from within the state transformer and luckily stumped upon the 'get' and 'put' functions at our disposal to do exactly that.  We had to the thread the store with all the objects attributes before updating them with their initializations which required more than a simple fold.  As for dispatch, things went reasonably smoothly. The operational made for an easy implementation. For let expressions, we treated multiple bindings just like the operational semantics recommended by cascading the first binding into another let expression which contained the remaining bindings. Later we realized that cool's built in functions would cause us a bit of pain (esp. copy()), but we seemed to get around these alright.

With exception handling and edge cases left to implement, we had onlt our tests to depend on and as we made the final ascent to a submittable assignment. In the end we were happy with our submission.

Our first test case is the behemoth that we used for our primary testing during development.  We would add features in that file and tinker with our interpretter until we got the correct functionality.  The second is an example that tests the correct functionality of the copy() method which we struggled with for a short while.  The third is a file checking all types of value comparrisons and the fourth takes a look at all kinds of dispatch expressions and general Object Oriented problems. The final code should be reasonably well documented and is broken up into sections based on functionality. The main eval loop follows closely with the operational semantics and thus should be fairly comprehensive.

This class challenged me at a level that I had yet to be challenged.  I have sworn at the PL gods and thrown volleyballs every which way out of frustration, but what is the result of this semester of chaos? We were told at the beginning of the semester that the best course of action was to drop this course and never look back... We were told later before the drop date that there was still time to save our mortal souls... yet... here we are.  This class was rewarding like non other. Having developed a new love for the static typing arts and the free, correctness assurances of oCaml and haskell I have a whole new perspective on programming languages. This was an excellent class. Thank you.

    PS. Professor Weimer you are the man! Keep up the great work!
